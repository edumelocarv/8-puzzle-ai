import time
from Node import Node
from breath_first_search import bfs
from deep_first_search import dfs
from a_star_search import a_star_search
from heuristic_search import greedy_best_first_search_with_loop
from puzzle_game import Board

class TestAllAlgorithms:
    def __init__(self):
        # 5 casos de teste com diferentes dificuldades (todos sol√∫veis) - formato matriz 3x3
        self.test_cases = [
            ("Resolvido (0 movimentos)", [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 0]
            ]),
            ("Muito f√°cil (2 movimentos)", [
                [1, 2, 3],
                [4, 5, 6],
                [0, 7, 8]
            ]),
            ("M√©dio (6 movimentos)", [
                [1, 2, 3],
                [5, 0, 6],
                [4, 7, 8]
            ]),
            ("Dif√≠cil (14 movimentos)", [
                [2, 5, 3],
                [1, 0, 6],
                [4, 7, 8]
            ]),
            ("Muito dif√≠cil (31 movimentos)", [
                [8, 6, 7],
                [2, 5, 4],
                [3, 0, 1]
            ])
        ]
        
        # Algoritmos dispon√≠veis
        self.algorithms = {
            "BFS": self.test_bfs,
            "DFS": self.test_dfs,
            "Busca Heur√≠stica": self.test_heuristic,
            "A*": self.test_astar
        }
    
    def matrix_to_list(self, matrix):
        """Converte matriz 3x3 para lista 1D"""
        result = []
        for row in matrix:
            for element in row:
                result.append(element)
        return result
    
    def matrix_to_board(self, matrix):
        """Converte matriz 3x3 para objeto Board"""
        board = Board(matrix)
        return board
    
    def test_bfs(self, initial_matrix):
        """Testa o algoritmo BFS"""
        try:
            # Converte matriz para lista 1D para o BFS
            initial_list = self.matrix_to_list(initial_matrix)
            root = Node(initial_list, None, None)
            
            start_time = time.perf_counter()
            result = bfs(root)
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            
            if result is None or result[0] is None:
                return {
                    "success": False,
                    "time": execution_time,
                    "error": "Nenhuma solu√ß√£o encontrada"
                }
            
            solve_node, visited_nodes, explored_states_len = result
            path = solve_node.path()
            solution_depth = len(path) - 1
            
            # Extrai movimentos
            moves = [node.action for node in path[1:] if node.action]
            
            return {
                "success": True,
                "time": execution_time,
                "solution_depth": solution_depth,
                "visited_nodes": visited_nodes,
                "explored_states": explored_states_len,
                "moves": moves,
                "path": path
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "time": 0
            }
    
    def test_dfs(self, initial_matrix):
        """Testa o algoritmo DFS"""
        try:
            # Converte matriz para lista 1D para o DFS
            initial_list = self.matrix_to_list(initial_matrix)
            root = Node(initial_list, None, None)
            
            start_time = time.perf_counter()
            result = dfs(root)
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            
            if result is None or result[0] is None:
                return {
                    "success": False,
                    "time": execution_time,
                    "error": "Nenhuma solu√ß√£o encontrada"
                }
            
            solve_node, visited_nodes, explored_states_len = result
            path = solve_node.path()
            solution_depth = len(path) - 1
            
            # Extrai movimentos
            moves = [node.action for node in path[1:] if node.action]
            
            return {
                "success": True,
                "time": execution_time,
                "solution_depth": solution_depth,
                "visited_nodes": visited_nodes,
                "explored_states": explored_states_len,
                "moves": moves,
                "path": path
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "time": 0
            }
    
    def test_heuristic(self, initial_matrix):
        """Testa a Busca Heur√≠stica"""
        try:
            # Converte matriz para Board para a busca heur√≠stica
            board = self.matrix_to_board(initial_matrix)
            
            start_time = time.perf_counter()
            moves, steps = greedy_best_first_search_with_loop(board)
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            
            if moves is None:
                return {
                    "success": False,
                    "time": execution_time,
                    "error": f"Algoritmo entrou em loop ap√≥s {steps} movimentos"
                }
            
            if not moves:  # J√° resolvido
                return {
                    "success": True,
                    "time": execution_time,
                    "solution_depth": 0,
                    "visited_nodes": steps,
                    "explored_states": steps,
                    "moves": [],
                    "path": []
                }
            
            return {
                "success": True,
                "time": execution_time,
                "solution_depth": len(moves),
                "visited_nodes": steps,
                "explored_states": steps,  # Aproxima√ß√£o
                "moves": moves,
                "path": []  # Busca heur√≠stica n√£o retorna caminho completo
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "time": 0
            }
    
    def test_astar(self, initial_matrix):
        """Testa o algoritmo A*"""
        try:
            # Converte matriz para Board para o A*
            board = self.matrix_to_board(initial_matrix)
            
            start_time = time.perf_counter()
            result = a_star_search(board)
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            
            if result is None or result[0] is None:
                return {
                    "success": False,
                    "time": execution_time,
                    "error": "Nenhuma solu√ß√£o encontrada"
                }
            
            solution_node, metrics = result
            path = solution_node.path()
            
            # Extrai movimentos
            moves = [node.action for node in path[1:] if node.action]
            solution_depth = len(moves)
            
            return {
                "success": True,
                "time": execution_time,
                "solution_depth": solution_depth,
                "visited_nodes": metrics['visited_nodes'],
                "explored_states": metrics['explored_states'],
                "max_frontier": metrics.get('max_frontier', 0),
                "moves": moves,
                "path": path
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "time": 0
            }
    
    def run_single_test(self, algorithm_name, test_name, initial_matrix):
        """Executa um teste individual"""
        print(f"\n{'='*70}")
        print(f"üß™ TESTE: {algorithm_name} - {test_name}")
        print(f"{'='*70}")
        print(f"Estado inicial:")
        for row in initial_matrix:
            print(f"  {row}")
        
        if algorithm_name not in self.algorithms:
            print(f"‚ùå Algoritmo '{algorithm_name}' n√£o encontrado!")
            return None
        
        result = self.algorithms[algorithm_name](initial_matrix)
        
        if result["success"]:
            print(f"‚úÖ SUCESSO!")
            print(f"‚è±Ô∏è  Tempo de execu√ß√£o: {result['time']:.4f} segundos")
            print(f"üìä Profundidade da solu√ß√£o: {result['solution_depth']} movimentos")
            print(f"üîç N√≥s visitados: {result['visited_nodes']}")
            print(f"üíæ Estados explorados: {result['explored_states']}")
            
            if 'max_frontier' in result:
                print(f"üöÄ Fronteira m√°xima: {result['max_frontier']}")
            
            if result['solution_depth'] > 0:
                print(f"üìà Efici√™ncia: {result['visited_nodes']/result['solution_depth']:.2f} n√≥s/movimento")
            
            # Mostra os primeiros movimentos
            if result.get('moves') and len(result['moves']) > 0:
                moves_str = ' ‚Üí '.join(result['moves'][:10])
                if len(result['moves']) > 10:
                    moves_str += f" ... (+{len(result['moves'])-10} movimentos)"
                print(f"üõ§Ô∏è  Movimentos: {moves_str}")
        else:
            print(f"‚ùå FALHOU: {result.get('error', 'Erro desconhecido')}")
            if 'time' in result:
                print(f"‚è±Ô∏è  Tempo at√© falha: {result['time']:.4f} segundos")
        
        return result
    
    def run_algorithm_tests(self, algorithm_name):
        """Testa um algoritmo em todos os casos de teste"""
        print(f"\n{'='*80}")
        print(f"üöÄ TESTANDO ALGORITMO: {algorithm_name}")
        print(f"{'='*80}")
        
        results = []
        total_time = 0
        
        for test_name, initial_matrix in self.test_cases:
            result = self.run_single_test(algorithm_name, test_name, initial_matrix)
            results.append((test_name, result))
            
            if result and result["success"]:
                total_time += result["time"]
        
        self.print_algorithm_summary(algorithm_name, results, total_time)
        return results
    
    def run_all_tests(self):
        """Executa todos os algoritmos em todos os casos de teste"""
        all_results = {}
        
        print("üåü INICIANDO BATERIA COMPLETA DE TESTES")
        print("=" * 80)
        
        for algorithm_name in self.algorithms.keys():
            all_results[algorithm_name] = self.run_algorithm_tests(algorithm_name)
        
        # Imprime compara√ß√£o final
        self.print_comparison_table(all_results)
        return all_results
    
    def run_comparison_test(self, test_index=2):
        """Compara todos os algoritmos em um caso espec√≠fico"""
        if test_index >= len(self.test_cases):
            print("‚ùå √çndice de teste inv√°lido!")
            return
        
        test_name, initial_matrix = self.test_cases[test_index]
        print(f"\n{'='*80}")
        print(f"‚öîÔ∏è  COMPARA√á√ÉO DE ALGORITMOS - {test_name}")
        print(f"Estado inicial:")
        for row in initial_matrix:
            print(f"  {row}")
        print(f"{'='*80}")
        
        results = {}
        for algorithm_name in self.algorithms.keys():
            print(f"\n--- {algorithm_name} ---")
            result = self.algorithms[algorithm_name](initial_matrix)
            results[algorithm_name] = result
            
            if result["success"]:
                efficiency = result['visited_nodes']/max(result['solution_depth'], 1)
                print(f"‚è±Ô∏è {result['time']:.4f}s | "
                      f"üìä {result['solution_depth']} mov | "
                      f"üîç {result['visited_nodes']} n√≥s | "
                      f"üìà {efficiency:.1f} n√≥s/mov")
            else:
                print(f"‚ùå Falhou: {result.get('error', 'Erro desconhecido')}")
        
        # Ordena por tempo para mostrar ranking
        successful_results = [(name, res) for name, res in results.items() if res["success"]]
        successful_results.sort(key=lambda x: x[1]["time"])
        
        if successful_results:
            print(f"\nüèÜ RANKING POR TEMPO:")
            for i, (name, res) in enumerate(successful_results, 1):
                print(f"  {i}¬∫ {name}: {res['time']:.4f}s")
        
        return results
    
    def print_algorithm_summary(self, algorithm_name, results, total_time):
        """Imprime resumo de um algoritmo"""
        print(f"\nüìã RESUMO - {algorithm_name}")
        print("-" * 60)
        
        successful_tests = 0
        total_moves = 0
        total_nodes = 0
        total_states = 0
        
        for test_name, result in results:
            if result and result["success"]:
                successful_tests += 1
                total_moves += result["solution_depth"]
                total_nodes += result["visited_nodes"]
                total_states += result["explored_states"]
        
        print(f"‚úÖ Testes bem-sucedidos: {successful_tests}/{len(results)}")
        print(f"‚è±Ô∏è  Tempo total: {total_time:.4f} segundos")
        
        if successful_tests > 0:
            print(f"üìä M√©dia de movimentos: {total_moves/successful_tests:.1f}")
            print(f"üîç M√©dia de n√≥s visitados: {total_nodes/successful_tests:.1f}")
            print(f"üíæ M√©dia de estados explorados: {total_states/successful_tests:.1f}")
            print(f"üìà Efici√™ncia m√©dia: {(total_nodes/max(total_moves, 1)):.1f} n√≥s/movimento")
    
    def print_comparison_table(self, all_results):
        """Imprime tabela comparativa final"""
        print(f"\n{'='*90}")
        print("üìä TABELA COMPARATIVA COMPLETA")
        print(f"{'='*90}")
        
        # Cabe√ßalho
        header = f"{'Algoritmo':<18} | {'Caso':<25} | {'Tempo (s)':<10} | {'Movs':<6} | {'N√≥s':<8} | {'Estados':<8}"
        print(header)
        print("-" * len(header))
        
        for algorithm_name, test_results in all_results.items():
            for test_name, result in test_results:
                if result and result["success"]:
                    print(f"{algorithm_name:<18} | {test_name:<25} | "
                          f"{result['time']:<10.4f} | {result['solution_depth']:<6} | "
                          f"{result['visited_nodes']:<8} | {result['explored_states']:<8}")
                else:
                    error_msg = result.get('error', 'Falhou')[:15] if result else 'Erro'
                    print(f"{algorithm_name:<18} | {test_name:<25} | {'FALHOU':<10} | {'-':<6} | {'-':<8} | {error_msg:<8}")
        
        # Estat√≠sticas gerais por algoritmo
        print(f"\nüìà ESTAT√çSTICAS GERAIS:")
        print("-" * 60)
        
        for algorithm_name, test_results in all_results.items():
            successful = [r for _, r in test_results if r and r["success"]]
            if successful:
                avg_time = sum(r["time"] for r in successful) / len(successful)
                avg_moves = sum(r["solution_depth"] for r in successful) / len(successful)
                avg_nodes = sum(r["visited_nodes"] for r in successful) / len(successful)
                
                print(f"{algorithm_name:<15}: {len(successful)}/5 sucessos | "
                      f"Tempo m√©dio: {avg_time:.4f}s | "
                      f"Movimentos m√©dios: {avg_moves:.1f} | "
                      f"N√≥s m√©dios: {avg_nodes:.1f}")

def main():
    """Fun√ß√£o principal para executar os testes"""
    tester = TestAllAlgorithms()
    
    print("üß© SISTEMA COMPLETO DE TESTES PARA ALGORITMOS DO 8-PUZZLE")
    print("=" * 70)
    
    while True:
        print("\nüìã OP√á√ïES DISPON√çVEIS:")
        print("1. üöÄ Executar TODOS os algoritmos em TODOS os casos")
        print("2. üéØ Testar algoritmo espec√≠fico")
        print("3. ‚öîÔ∏è  Comparar algoritmos em caso espec√≠fico")
        print("4. üìä Teste r√°pido (caso m√©dio)")
        print("5. üìã Listar casos de teste")
        print("6. ‚ùå Sair")
        
        choice = input("\nüëâ Escolha uma op√ß√£o (1-6): ").strip()
        
        if choice == "1":
            tester.run_all_tests()
            
        elif choice == "2":
            print("\nüîß ALGORITMOS DISPON√çVEIS:")
            algorithms = list(tester.algorithms.keys())
            for i, algo in enumerate(algorithms):
                print(f"  {i}: {algo}")
            
            try:
                algo_idx = int(input("\nüëâ Digite o n√∫mero do algoritmo (0-3): "))
                if 0 <= algo_idx < len(algorithms):
                    tester.run_algorithm_tests(algorithms[algo_idx])
                else:
                    print("‚ùå N√∫mero inv√°lido!")
            except ValueError:
                print("‚ùå Por favor, digite um n√∫mero v√°lido!")
                
        elif choice == "3":
            print("\nüìã CASOS DE TESTE DISPON√çVEIS:")
            for i, (name, matrix) in enumerate(tester.test_cases):
                print(f"  {i}: {name}")
                for row in matrix:
                    print(f"     {row}")
                print()
            
            try:
                test_idx = int(input("\nüëâ Digite o n√∫mero do caso (0-4): "))
                tester.run_comparison_test(test_idx)
            except ValueError:
                print("‚ùå Por favor, digite um n√∫mero v√°lido!")
                
        elif choice == "4":
            tester.run_comparison_test(2)  # Caso m√©dio
            
        elif choice == "5":
            print(f"\nüìã CASOS DE TESTE ({len(tester.test_cases)} dispon√≠veis):")
            for i, (name, matrix) in enumerate(tester.test_cases):
                print(f"  {i}: {name}")
                print(f"     Estado:")
                for row in matrix:
                    print(f"       {row}")
                print()
                
        elif choice == "6":
            print("üëã Encerrando testes. At√© logo!")
            break
            
        else:
            print("‚ùå Op√ß√£o inv√°lida! Tente novamente.")

if __name__ == "__main__":
    main()